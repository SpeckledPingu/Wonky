from sqlalchemy.orm import Session
from sqlalchemy import or_
from sqlalchemy.dialects.sqlite import insert
from app import models, schemas
from app.core import security
import uuid
import datetime
from typing import List


def create_project(db: Session, project: schemas.ProjectCreate, user_id: int):
    """
    Creates a new project for a user.
    """
    db_project = models.Project(**project.model_dump(), user_id=user_id)
    db.add(db_project)
    db.commit()
    db.refresh(db_project)
    return db_project

def get_projects_by_user(db: Session, user_id: int):
    """
    Retrieves all projects owned by a specific user.
    """
    return db.query(models.Project).filter(models.Project.user_id == user_id).all()


# --- User and Auth Functions ---
def get_user_by_email(db: Session, email: str):
    return db.query(models.User).filter(models.User.email == email).first()


def create_user(db: Session, user: schemas.UserCreate):
    hashed_password = security.get_password_hash(user.password)
    db_user = models.User(email=user.email, username=user.username, hashed_password=hashed_password)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user


def authenticate_user(db: Session, email: str, password: str):
    user = get_user_by_email(db, email)
    if not user or not security.verify_password(password, user.hashed_password):
        return None
    return user


def get_projects_by_user(db: Session, user_id: int):
    return db.query(models.Project).filter(models.Project.user_id == user_id).all()


# === Document & Search CRUD ===
def get_document(db: Session, doc_id: str, project_id: int, user_id: int):
    """
    Fetches a single document, ensuring it belongs to the specified project and user
    by joining the projects table and checking the user_id.
    """
    return db.query(models.Document) \
        .join(models.Project) \
        .filter(
        models.Document.id == doc_id,
        models.Document.project_id == project_id,
        models.Project.user_id == user_id
    ).first()


def search_documents(db: Session, project_id: int, query: str):
    search_term = f"%{query.lower()}%"
    return db.query(models.Document).filter(
        models.Document.project_id == project_id,
        or_(
            models.Document.title.ilike(search_term),
            models.Document.content.ilike(search_term)
        )
    ).all()


def search_extractions(db: Session, project_id: int, query: schemas.ExtractionSearchQuery):
    db_query = db.query(models.Extraction).filter(models.Extraction.project_id == project_id)
    if query.contentTypes:
        db_query = db_query.filter(models.Extraction.type.in_(query.contentTypes))
    if query.stances:
        db_query = db_query.filter(models.Extraction.stance.in_(query.stances))
    if query.query:
        search_term = f"%{query.query.lower()}%"
        db_query = db_query.filter(models.Extraction.content.ilike(search_term))
    return db_query.all()


def update_document(db: Session, doc_id: str, project_id: int, user_id: int, doc_update: schemas.DocumentUpdateRequest):
    # Use the secure get_document function to verify ownership before updating
    db_doc = get_document(db, doc_id=doc_id, project_id=project_id, user_id=user_id)
    if not db_doc:
        return None
    
    if doc_update.tags is not None:
        db_doc.tags = db.query(models.Tag).filter(models.Tag.name.in_(doc_update.tags)).all()
    
    if doc_update.color is not None:
        db_doc.color = doc_update.color
    
    db.commit()
    db.refresh(db_doc)
    return db_doc


# === Report CRUD ===
def get_report(db: Session, report_id: str, project_id: int, user_id: int):
    """
    Fetches a single report, ensuring it belongs to the specified project and user.
    """
    return db.query(models.Report) \
        .join(models.Project) \
        .filter(
        models.Report.id == report_id,
        models.Report.project_id == project_id,
        models.Project.user_id == user_id
    ).first()


def get_reports_by_project(db: Session, project_id: int):
    return db.query(models.Report).filter(models.Report.project_id == project_id).order_by(
        models.Report.generated_at.desc()).all()


def create_report_from_job(db: Session, job_request: schemas.ProcessingJobRequest, project_id: int, content: str):
    """
    Creates a new Report in the database, now accepting pre-generated content.
    """
    source_docs = get_documents_by_ids(db, doc_ids=job_request.documentIds, project_id=project_id)
    
    db_report = models.Report(
        id=f"report-{uuid.uuid4()}",
        project_id=project_id,
        title=f"Analysis Report on {job_request.analysisType}",
        content=content,  # Use the content generated by the LLM
        analysis_type=job_request.analysisType,
        generated_at=datetime.datetime.now(),
        source_documents=source_docs
    )
    db.add(db_report)
    db.commit()
    db.refresh(db_report)
    return db_report


# === Processing Bucket CRUD ===
def get_bucket_items(db: Session, project_id: int):
    return db.query(models.ProcessingBucketItem.document_id).filter(
        models.ProcessingBucketItem.project_id == project_id).all()


def add_to_bucket(db: Session, doc_id: str, project_id: int):
    stmt = insert(models.ProcessingBucketItem).values(project_id=project_id, document_id=doc_id)
    stmt = stmt.on_conflict_do_nothing(index_elements=['project_id', 'document_id'])
    db.execute(stmt)
    db.commit()
    return {"status": "success"}


def remove_from_bucket(db: Session, doc_ids: list[str], project_id: int):
    db.query(models.ProcessingBucketItem).filter(
        models.ProcessingBucketItem.project_id == project_id,
        models.ProcessingBucketItem.document_id.in_(doc_ids)
    ).delete(synchronize_session=False)
    db.commit()

def get_saved_results(db: Session, project_id: int):
    """
    Retrieves all saved search result documents for a specific project.
    """
    print("Get Saved Results Project ID:", project_id)
    return db.query(models.Document)\
        .join(models.SavedSearchResult, models.SavedSearchResult.document_id == models.Document.id)\
        .filter(models.SavedSearchResult.project_id == project_id)\
        .order_by(models.SavedSearchResult.saved_at.desc())\
        .all()


def upsert_and_save_search_results(db: Session, results: List[schemas.RawSearchResult], project_id: int) -> List[
    models.Document]:
    """
    Takes a list of raw search results, upserts them into the main documents table,
    and saves them to the project's saved_search_results list.
    This makes search results a persistent part of the user's project.
    """
    doc_ids = [result.id for result in results]
    
    for result in results:
        # Step 1: Upsert the document into the global 'documents' table.
        # This uses ON CONFLICT DO NOTHING, so if a document with this ID already
        # exists, it won't be overwritten. This is crucial for preserving user edits.
        doc_insert_stmt = insert(models.Document).values(
            id=result.id,
            title=result.title,
            content=result.content,
            project_id=project_id  # Note: This assumes the first project to import a doc "claims" it.
        )
        doc_conflict_stmt = doc_insert_stmt.on_conflict_do_nothing(index_elements=['id'])
        db.execute(doc_conflict_stmt)
        
        # Step 2: Upsert the link in the 'saved_search_results' table.
        # This connects the document to the current project.
        saved_result_stmt = insert(models.SavedSearchResult).values(
            project_id=project_id,
            document_id=result.id
        )
        saved_conflict_stmt = saved_result_stmt.on_conflict_do_nothing(index_elements=['project_id', 'document_id'])
        db.execute(saved_conflict_stmt)
    
    # Commit all the inserts at once.
    db.commit()
    
    # Step 3: Fetch and return the full Document objects that are now saved for this project.
    # This ensures the frontend gets the complete, database-consistent data.
    saved_docs = db.query(models.Document).filter(
        models.Document.id.in_(doc_ids),
        models.Document.project_id == project_id
    ).all()
    print(doc_ids)
    print(saved_docs)
    
    return saved_docs


def add_saved_result(db: Session, doc_id: str, project_id: int):
    """
    Adds a document to the saved results list for a project, ignoring duplicates.
    """
    stmt = insert(models.SavedSearchResult).values(
        project_id=project_id,
        document_id=doc_id
    )
    stmt = stmt.on_conflict_do_nothing(
        index_elements=['project_id', 'document_id']
    )
    db.execute(stmt)
    db.commit()
    return {"status": "success"}

def remove_saved_result(db: Session, doc_id: str, project_id: int):
    """
    Removes a document from the saved results list for a project.
    """
    db.query(models.SavedSearchResult).filter(
        models.SavedSearchResult.project_id == project_id,
        models.SavedSearchResult.document_id == doc_id
    ).delete(synchronize_session=False)
    db.commit()


def import_document_from_search(db: Session, doc_data: schemas.RawSearchResult, project_id: int):
    """
    Imports a raw search result into a project, creating a new document.
    """
    existing_doc = db.query(models.Document).filter(
        models.Document.id == doc_data.id,
        models.Document.project_id == project_id
    ).first()
    
    if existing_doc:
        return existing_doc
    
    tags_to_assign = []
    for tag_name in doc_data.tags:
        db_tag = db.query(models.Tag).filter(models.Tag.name == tag_name).first()
        if not db_tag:
            db_tag = models.Tag(name=tag_name)
            db.add(db_tag)
            db.commit()
            db.refresh(db_tag)
        tags_to_assign.append(db_tag)
    
    db_doc = models.Document(
        id=doc_data.id,
        title=doc_data.title,
        content=doc_data.content,
        summary=doc_data.content[:500],  # <-- Create a default summary on import
        project_id=project_id,
        tags=tags_to_assign
    )
    db.add(db_doc)
    db.commit()
    db.refresh(db_doc)
    return db_doc

def get_documents_by_ids(db: Session, doc_ids: List[str], project_id: int) -> List[models.Document]:
    """
    Fetches a list of full document models from the database by their IDs.
    """
    return db.query(models.Document).filter(
        models.Document.project_id == project_id,
        models.Document.id.in_(doc_ids)
    ).all()


def get_report(db: Session, report_id: str, project_id: int):
    return db.query(models.Report).filter(models.Report.id == report_id, models.Report.project_id == project_id).first()

def get_reports_by_project(db: Session, project_id: int):
    return db.query(models.Report).filter(models.Report.project_id == project_id).order_by(models.Report.generated_at.desc()).all()
