# prompt_composer_page.py
from nicegui import ui, app  # Added app import
from collections import defaultdict
import uuid  # For generating unique IDs if needed, though SQL IDs are preferred with backend


# --- Placeholder for Backend Functions (Illustrative) ---
# In a real application, these would interact with your SQL database.
# You would replace these placeholders with your actual database logic.

def db_load_components_for_user(user_id: str):
    # SQL_HOOK: Example: SELECT * FROM prompt_components WHERE user_id = ?
    print(f"SQL_HOOK: (Placeholder) Loading components for user {user_id}")
    return []  # Return list of component dicts


def db_load_library_for_user(user_id: str):
    # SQL_HOOK: Example: SELECT * FROM prompt_library WHERE user_id = ?
    print(f"SQL_HOOK: (Placeholder) Loading library items for user {user_id}")
    return []  # Return list of library dicts


def db_save_item(user_id: str, item: dict, collection_type: str):
    # SQL_HOOK: Example: INSERT INTO ... or UPDATE ...
    # Item ID might be generated by the DB here and returned.
    print(f"SQL_HOOK: (Placeholder) Saving item for user {user_id} to {collection_type}: {item['name']}")
    return item.get("id", str(uuid.uuid4()))  # Return DB-generated ID or existing ID


def db_delete_item(user_id: str, item_id: str, collection_type: str):
    # SQL_HOOK: Example: DELETE FROM ... WHERE id = ? AND user_id = ?
    print(f"SQL_HOOK: (Placeholder) Deleting item {item_id} for user {user_id} from {collection_type}")
    return True


def create_prompt_composer_page_content():
    """
    Creates the UI for the prompt composer page using app.storage.user.
    This function should be called within a @ui.page decorated function in your main.py.
    """

    # Initialize data in app.storage.user if it doesn't exist.
    # This provides per-user storage in the browser's local storage.
    # SQL_HOOK: This local initialization could be augmented or replaced by loading from a SQL backend.
    # For example, fetch data based on a logged-in user ID.
    # For simplicity, we assume a generic user or an anonymous session here for app.storage.user.
    # A real user_id would be determined by your authentication system.
    placeholder_user_id = "current_user_example"  # Replace with actual user identification

    if 'prompt_components' not in app.storage.user:
        # SQL_HOOK: Load initial components from SQL backend for the user
        # app.storage.user['prompt_components'] = db_load_components_for_user(placeholder_user_id)
        app.storage.user['prompt_components'] = [
            {"id": "comp1_user", "name": "User's Conciseness Rule", "type": "rules",
             "content": "Keep it short and sweet for this user."},
            {"id": "comp2_user", "name": "User's Factual Check", "type": "reasoning",
             "content": "Double-check facts before responding to this user."}
        ]  # Default if DB is empty or not used
    if 'prompt_library' not in app.storage.user:
        # SQL_HOOK: Load initial library items from SQL backend for the user
        # app.storage.user['prompt_library'] = db_load_library_for_user(placeholder_user_id)
        app.storage.user['prompt_library'] = [
            {"id": "lib1_user", "name": "User's Friendly Persona", "type": "personas",
             "content": "Act as a friendly and helpful assistant for this user."},
        ]  # Default if DB is empty or not used

    # For app.storage.user, ID generation needs to be handled carefully.
    # If not using a backend, a simple counter in storage can work, but UUIDs are better for local.
    # With a SQL backend, the DB would typically generate IDs.
    if 'next_comp_id_counter' not in app.storage.user:
        app.storage.user['next_comp_id_counter'] = len(app.storage.user['prompt_components']) + 1
    if 'next_lib_id_counter' not in app.storage.user:
        app.storage.user['next_lib_id_counter'] = len(app.storage.user['prompt_library']) + 1

    composer_textarea_ref = [None]  # To hold reference to the textarea UI element

    # --- Helper Functions ---
    def add_content_to_composer(content_to_add: str):
        if composer_textarea_ref[0]:
            current_value = composer_textarea_ref[0].value or ""
            composer_textarea_ref[0].set_value(f"{current_value}\n{content_to_add}".strip())
            ui.notify("Content added to composer.", type='positive')
        else:
            ui.notify("Composer text area not ready.", type='negative')

    def view_and_add_dialog(item: dict, item_category: str):
        with ui.dialog() as dialog, ui.card().classes('min-w-[400px] max-w-[600px]'):
            ui.label(f"Viewing: {item['name']}").classes('text-h6 font-medium text-gray-700')
            ui.badge(f"{item_category.capitalize()}: {item['type']}",
                     color='blue' if item_category == 'component' else 'green').classes('my-1')
            with ui.scroll_area().classes('h-48 border p-3 rounded-md my-3 bg-gray-50 text-sm'):
                ui.markdown(item['content'])
            with ui.row().classes('w-full justify-end pt-2 gap-x-2'):
                ui.button("Add to Composer",
                          on_click=lambda: (add_content_to_composer(item['content']), dialog.close()),
                          icon='add_circle_outline', color='primary')
                ui.button("Close", on_click=dialog.close, color='gray').props('outline')
        dialog.open()

    def delete_item(item_id: str, list_type: str):
        current_user_id = placeholder_user_id  # Get current user ID
        if list_type == "component":
            components = list(app.storage.user.get('prompt_components', []))
            original_len = len(components)
            components = [comp for comp in components if comp.get("id") != item_id]
            if len(components) < original_len:
                app.storage.user['prompt_components'] = components  # Update storage
                # SQL_HOOK: Delete item with item_id from SQL backend for current_user_id
                # db_delete_item(current_user_id, item_id, "component")
                components_pane_ui.refresh()
                ui.notify("Component deleted.", type='info')
            else:
                ui.notify(f"Component with ID {item_id} not found.", type='warning')
        elif list_type == "library":
            library_items = list(app.storage.user.get('prompt_library', []))
            original_len = len(library_items)
            library_items = [lib for lib in library_items if lib.get("id") != item_id]
            if len(library_items) < original_len:
                app.storage.user['prompt_library'] = library_items  # Update storage
                # SQL_HOOK: Delete item with item_id from SQL backend for current_user_id
                # db_delete_item(current_user_id, item_id, "library")
                library_pane_ui.refresh()
                ui.notify("Library prompt deleted.", type='info')
            else:
                ui.notify(f"Library prompt with ID {item_id} not found.", type='warning')

    # --- UI Panes (Refreshable) ---
    @ui.refreshable
    def components_pane_ui():
        ui.label("Prompt Components").classes('text-xl font-semibold mb-3 text-blue-700')
        # Read from app.storage.user
        current_components = app.storage.user.get('prompt_components', [])
        if not current_components:
            ui.label("No components available for this user.").classes('text-gray-500 italic')
            return

        components_by_type = defaultdict(list)
        for comp in current_components:
            components_by_type[comp['type']].append(comp)
        sorted_types = sorted(components_by_type.keys())

        for comp_type in sorted_types:
            with ui.expansion(text=comp_type.capitalize(), icon='category').classes('w-full rounded-lg mb-2'):
                with ui.column().classes('gap-y-3 w-full p-2'):
                    if not components_by_type[comp_type]:
                        ui.label(f"No {comp_type} components available.").classes('text-gray-400 italic text-sm ml-2')
                    for comp in components_by_type[comp_type]:
                        with ui.card().classes(
                                'w-full shadow-md hover:shadow-lg transition-shadow duration-150 ease-in-out'):
                            with ui.card_section():
                                ui.label(comp["name"]).classes('text-lg font-medium text-gray-800')
                                ui.markdown(
                                    f"_{comp['content'][:80]}{'...' if len(comp['content']) > 80 else ''}_").classes(
                                    'text-sm text-gray-600 mt-1 h-12 overflow-hidden')
                            with ui.card_actions().classes('justify-start q-pt-none mt-2'):
                                ui.button("View/Add", on_click=lambda c=comp: view_and_add_dialog(c, "component"),
                                          icon='visibility', color='primary').props('dense flat')
                                ui.button(icon='delete_outline',
                                          on_click=lambda c_id=comp.get("id"): delete_item(c_id, "component"),
                                          color='red-500').props('flat dense round')

    @ui.refreshable
    def library_pane_ui():
        ui.label("Prompt Library").classes('text-xl font-semibold mb-3 text-green-700')
        # Read from app.storage.user
        current_library_items = app.storage.user.get('prompt_library', [])
        if not current_library_items:
            ui.label("No library prompts available for this user.").classes('text-gray-500 italic')
            return

        library_items_by_type = defaultdict(list)
        for lib_item in current_library_items:
            library_items_by_type[lib_item['type']].append(lib_item)
        sorted_types = sorted(library_items_by_type.keys())

        for lib_type in sorted_types:
            with ui.expansion(text=lib_type.capitalize(), icon='collections_bookmark').classes(
                    'w-full rounded-lg mb-2'):
                with ui.column().classes('gap-y-3 w-full p-2'):
                    if not library_items_by_type[lib_type]:
                        ui.label(f"No {lib_type} library items available.").classes('text-gray-400 italic text-sm ml-2')
                    for lib_item in library_items_by_type[lib_type]:
                        with ui.card().classes(
                                'w-full shadow-md hover:shadow-lg transition-shadow duration-150 ease-in-out'):
                            with ui.card_section():
                                ui.label(lib_item["name"]).classes('text-lg font-medium text-gray-800')
                                ui.markdown(
                                    f"_{lib_item['content'][:80]}{'...' if len(lib_item['content']) > 80 else ''}_").classes(
                                    'text-sm text-gray-600 mt-1 h-12 overflow-hidden')
                            with ui.card_actions().classes('justify-start q-pt-none mt-2'):
                                ui.button("View/Add",
                                          on_click=lambda item=lib_item: view_and_add_dialog(item, "library"),
                                          icon='visibility', color='primary').props('dense flat')
                                ui.button(icon='delete_outline',
                                          on_click=lambda l_id=lib_item.get("id"): delete_item(l_id, "library"),
                                          color='red-500').props('flat dense round')

    # --- Main Page Layout (Using Splitters for 3 Panes) ---
    with ui.splitter(value=30).classes('w-full h-screen') as main_splitter:
        with main_splitter.before:
            with ui.column().classes('p-4 w-full h-full overflow-auto bg-blue-50 rounded-lg shadow-inner'):
                components_pane_ui()

        with main_splitter.after:
            with ui.splitter(value=50, horizontal=False).classes('w-full h-full') as right_area_splitter:
                with right_area_splitter.before:
                    with ui.column().classes('p-4 w-full h-full overflow-auto bg-gray-100 rounded-lg shadow-inner'):
                        ui.label("Prompt Composer").classes('text-xl font-semibold mb-4 text-purple-700')

                        main_type_options = {"Component": "Prompt Component", "Library": "Prompt Library"}
                        main_type_select = ui.select(main_type_options, label="1. Save to which collection?",
                                                     value="Component").classes('w-full mt-1')
                        prompt_name_input = ui.input(label="2. Give it a name").classes('w-full mt-3')
                        subtype_select = ui.select([], label="3. Select specific type").classes('w-full mt-3')

                        def update_subtype_options(e=None):
                            target_value = main_type_select.value
                            new_options = ["rules", "reasoning"] if target_value == "Component" else ["actions",
                                                                                                      "personas"]
                            subtype_select.options = new_options
                            if new_options and (subtype_select.value not in new_options or not subtype_select.value):
                                subtype_select.set_value(new_options[0])
                            elif not new_options:
                                subtype_select.set_value(None)

                        main_type_select.on('update:model-value', update_subtype_options)
                        update_subtype_options()

                        ui.label("4. Compose or edit prompt content:").classes(
                            'mt-4 mb-1 text-sm font-medium text-gray-600')
                        composer_textarea_ref[0] = ui.textarea(value='').props('outlined filled rows=30').classes(
                            'w-full mt-1 bg-white')

                        def save_prompt():
                            current_user_id = placeholder_user_id  # Get current user ID
                            name = prompt_name_input.value
                            content = composer_textarea_ref[0].value if composer_textarea_ref[0] else ""
                            specific_type = subtype_select.value
                            save_to_collection_key = main_type_select.value

                            if not all([name, content, specific_type, save_to_collection_key]):
                                ui.notify("All fields are required.", type='negative')
                                return

                            # SQL_HOOK: With SQL backend, ID would ideally be generated by the database.
                            # For app.storage.user without SQL, we use a counter or UUID.
                            new_item_id = ""
                            if save_to_collection_key == "Component":
                                new_item_id = f"comp_user{app.storage.user['next_comp_id_counter']}"
                                app.storage.user['next_comp_id_counter'] += 1
                            else:  # Library
                                new_item_id = f"lib_user{app.storage.user['next_lib_id_counter']}"
                                app.storage.user['next_lib_id_counter'] += 1

                            new_item = {"id": new_item_id, "name": name, "type": specific_type, "content": content}

                            # SQL_HOOK: Save new_item to SQL backend for current_user_id.
                            # The returned ID from db_save_item might be different if DB generates it.
                            # new_item['id'] = db_save_item(current_user_id, new_item, save_to_collection_key)

                            if save_to_collection_key == "Component":
                                components = list(app.storage.user.get('prompt_components', []))
                                components.append(new_item)
                                app.storage.user['prompt_components'] = components
                                components_pane_ui.refresh()
                                ui.notify("Prompt component saved!", type='positive')
                            elif save_to_collection_key == "Library":
                                library_items = list(app.storage.user.get('prompt_library', []))
                                library_items.append(new_item)
                                app.storage.user['prompt_library'] = library_items
                                library_pane_ui.refresh()
                                ui.notify("Prompt library item saved!", type='positive')

                            prompt_name_input.set_value("")
                            if composer_textarea_ref[0]:
                                composer_textarea_ref[0].set_value("")

                        ui.button("Save Prompt", on_click=save_prompt, icon='save').classes(
                            'mt-5 w-full bg-purple-600 text-white hover:bg-purple-700 py-2 text-base')

                with right_area_splitter.after:
                    with ui.column().classes('p-4 w-full h-full overflow-auto bg-green-50 rounded-lg shadow-inner'):
                        library_pane_ui()


# --- Example Usage (if this file were run directly for testing) ---
# if __name__ in {"__main__", "__mp_main__"}:
#     @ui.page('/')
#     def index_page():
#         # SQL_HOOK: User authentication would typically happen here or in a middleware.
#         # The user_id would then be available for db operations.
#         ui.query('body').style('font-family: "Inter", sans-serif;')
#         ui.label("Prompt Engineering Workbench (User Storage Mode)").classes(
#             'text-3xl font-bold text-center my-6 text-gray-700')
#         create_prompt_composer_page()
#
#
#     # IMPORTANT: For app.storage.user to be persistent and secure, provide a storage_secret.
#     # Make sure 'app' is available here if you are running this standalone.
#     # This might require app = ui.run(...) and then app.storage.secret = ... if not done implicitly
#     ui.run(title="Prompt Composer", storage_secret="PLEASE_CHANGE_THIS_SECRET_KEY", dark=False, reload=True, port=8080)
